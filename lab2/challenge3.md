如果 OS 无法提前知道当前硬件的可用物理内存范围，有何办法让 OS 获取可用物理内存范围？

方法1：参考实验指导书物理内存探测模块，即利用固件提供的服务

    比如实验中使用到的在RISC-V 中，由 bootloader 即 OpenSBI 固件完成物理内存探测。它会对包括物理内存在内的各外设进行扫描，将扫描结果以 DTB(Device Tree Blob) 的格式保存在物理内存中的某个地方。随后 OpenSBI 会将其地址保存在 a1 寄存器中，给我们使用。随后从a1寄存器中读取设备树数据存储地址，存入全局变量boot_dtb中，在kern_entry部分的初始化结束，正式进入到kern_init之后，会执行dtb_init函数来读取设备树结构中储存的相关信息，包括内存的起点和大小，均读取到了全局变量memory_base和memory_size中。

    同时这也是所有现代x86/ARM架构PC和服务器操作系统的标准做法。固件（BIOS或UEFI）在启动过程中已经对硬件进行了初始化和检测，其中就包括内存检测。

    以传统的 BIOS 系统为例，操作系统引导加载程序或内核本身在实模式下调用BIOS中断，并指定相关功能号。BIOS会返回一个描述内存映射的数据结构，即所谓的​​地址范围描述符​​。这个结构体不仅包含内存的起始地址和长度，更重要的是包含了一个​​类型字段​​。该字段包含不同对内存的标记，包括标记为操作系统可以自由使用的正常内存； 标记为被硬件保留不可用的内存等。这样便提供来最详细和准确的内存映射，能清晰区分可用和保留区域。

方法2：直接读取硬件配置信息

    比如在x86体系结构中，ACPI规范定义了系统描述表，其中包含了系统的硬件信息。虽然获取内存映射的主要途径是利用上面提到的固件服务，但ACPI表也提供了相关的系统地址布局信息，通过解析​​ACPI表即可获取​可用物理内存范围​。

方法3：写读探测法

    尝试向一个物理地址写入一个已知的值，然后再读回来，如果读写一致，则认为该内存存在且可用。

    但是这种方法仅可在一些极其简单或古老的，没有可靠的固件支持的系统上。因为如果向一个不存在的内存或设备寄存器写入数据，可能引发处理器异常或硬件错误，导致系统死机。而且有很多因素会导致其结果不准确，即使读写成功，该区域也可能被其他设备（如显存）使用，写入会破坏设备状态，同时CPU缓存可能导致读回的是缓存中的旧数据，而非实际内存数据，造成误判。

