# 练习2: 父进程复制自己的内存空间给子进程

## 1. 代码实现
copy_range 函数的作用是复制父进程的页表项对应的物理页内容到子进程新分配的物理页，并建立子进程的页表映射。
现有代码已完成遍历父进程的页表，对每个有效的页表项进行处理并为子进程分配新的物理页，现需实现将父进程物理页的内容复制到子进程物理页并建立子进程虚拟地址到新物理页的映射。

```
void *src_kvaddr = page2kva(page);
void *dst_kvaddr = page2kva(npage);
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
ret = page_insert(to, npage, start, perm);
```
- page2kva(page)：将物理页转换为内核虚拟地址，父进程和子进程的物理页都需要转换为内核虚拟地址后才能进行内存复制。
- 使用 memcpy 函数复制整个物理页，复制的是物理内存中的实际内容，包括代码、数据等。
- 使用 page_insert(to, npage, start, perm)：建立子进程页表映射。其参数 to 为子进程的页目录表，npage 为新分配的物理页，start 为子进程的虚拟地址（与父进程相同），perm 为继承父进程页表项的权限。

## 2. 如何设计实现Copy on Write机制？
- 父进程创建子进程时，不拷贝物理页，而是让父子进程共享物理页，同时将页表项设为只读。
- 此时当任一进程尝试写该页时，会触发page fault异常。
- 内核在page fault异常处理中，为写进程分配新物理页，拷贝原页数据，更新页表项为可写，之后进程继续执行写操作。