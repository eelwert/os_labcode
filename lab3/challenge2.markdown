

1. csrw sscratch, sp 和 csrrw s0, sscratch, x0 的操作分析

第一条指令：csrw sscratch, sp

csrw sscratch, sp  # 将sp写入sscratch寄存器

将当前的栈指针(sp)保存到sscratch寄存器中，来备份用户空间（或之前上下文）的栈指针，因为接下来要使用内核栈

第二条指令：csrrw s0, sscratch, x0

csrrw s0, sscratch, x0  # 读取sscratch到s0，同时将x0(零)写入sscratch

读取sscratch的当前值（即之前保存的sp）到s0寄存器，同时将x0（值永远为0）写入sscratch寄存器

从而获取原sp：将之前备份的sp值从sscratch恢复到s0，以便后续存入栈帧，设置标志：将sscratch清零，作为"来自内核"的标志




关键意义：当发生嵌套异常（异常处理程序中又发生异常）时，异常向量可以通过检查sscratch是否为0来判断异常来源：
• sscratch == 0：异常来自内核，不需要切换栈

• sscratch != 0：异常来自用户空间，需要切换栈

2. 为什么只保存而不恢复stval、scause等CSR？

这些CSR的特性分析：

CSR寄存器 作用 是否需要在异常返回时恢复

sstatus 处理器状态 需要恢复（影响执行环境）

sepc 异常返回地址 需要恢复（决定返回到哪里）

stval (sbadaddr) 异常附加信息 不需要恢复（只读性质）

scause 异常原因 不需要恢复（只读性质）

为什么不需要恢复？

stval (存储错误地址寄存器)：只包含引发异常的相关信息（如出错地址、非法指令本身等），是只读的，由硬件在异常发生时自动设置。异常返回时该值已经没有意义，下次异常会被硬件重新设置

scause (异常原因寄存器)：记录当前异常的原因代码，同样是只读的，由硬件设置。用于异常处理程序判断异常类型，处理完毕后就无用了

那么保存的意义是：

1. 为C处理程序提供信息：让C语言的trap()函数能够访问这些寄存器值
2. 调试和日志记录：在发生严重错误时，可以记录完整的异常上下文
3. 嵌套异常处理：如果发生嵌套异常，这些值会被新的异常上下文覆盖，需要保存当前状态

